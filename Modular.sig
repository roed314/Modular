177,0
S,CreateModularCurveRec,"Input: G : an open subgroup of GL(2,Zhat) 	 H : the open subgroup of SL(2,Zhat) that is the intersection of G with SL(2,Zhat) Output: A record of type ""ModularCurveRec"" that encodes the modular curve X_G with some basic and useful invariants computed",0,2,0,0,0,0,0,0,0,178,,0,0,178,,270,-38,-38,-38,-38,-38
S,CreateModularCurveRec,"CreateModularRec where G has level dividing N and its image in GL(2,Z/NZ) is generated by gens",0,2,0,0,0,0,0,0,0,82,,0,0,148,,270,-38,-38,-38,-38,-38
S,CreateModularCurveRec,CreateModularCurveRec with H computed directly,0,1,0,0,0,0,0,0,0,178,,270,-38,-38,-38,-38,-38
S,ModularFormToSequence,"Consider a modular form f for the modular curve M whose coefficients lie in Q(zeta_N), and let mult be a sequence of nonnegative integers with the same numbering as the cusps of M. Returns a finite sequence in Q(zeta_N) that consists of the first mult[i]+1 terms of the q-expansion of f at the i-th cusp of M for all i (with a chosen ordering). If ""OverQ"" is true, uses a basis of Q(zeta_N) over Q to obtain a matrix with rational entries instead",0,4,0,0,0,0,0,0,0,148,,0,0,82,,0,0,82,,0,0,270,,82,-38,-38,-38,-38,-38
S,SequenceToModularForm,"This is the reverse process of the function ""ModularFormToSequence""",0,4,0,0,0,0,0,0,0,-1,,0,0,-1,,0,0,-1,,0,0,-1,,270,-38,-38,-38,-38,-38
S,EisensteinFormsWeight1,"Input: N: an integer > 2 prec: a positive integer Output: An array E indexed by pairs [a,b] with a and b in Z/NZ. The term of E indexed by [a,b] is 2N times the q-expansion of the Eisenstein series E_(a,b)^1 up to O(qN^(prec)); it is given as a power series in qN:=q^(1/N) with coefficients in the cyclotomic field Q(zeta_N). For the definition of the Eisenstein series see section 2 of ""Fourier expansion at cusps"" by Brunault and Neururer. Remark: the extra factor of 2N ensures that all the coefficients are integral",0,2,0,0,0,0,0,0,0,-1,,0,0,-1,,457,-38,-38,-38,-38,-38
S,FindCuspData,"Consider a modular curve M=X_G given by a subgroup G of GL_2(Zhat). Let H be the intersection of G with SL(2,Zhat). Input: M : a record of type ""ModularCurveRec"" A : a matrix in SL(2,Zhat) given modulo an integer divisible by M`sl2level. Output: a triple of integers [i,j,e] such that A and e * M`cusps[i] * [1,1;0,1]^j lie in the same coset HSL(2,Zhat), where cusps[i] is the fixed matrix in SL(2,Z) describing the i-th cusp of M and e is 1 or -1. When G contains -I, we always choose e=1",0,2,0,0,0,0,0,0,0,-1,,0,0,-1,,82,-38,-38,-38,-38,-38
S,SturmPrecision,"Input: an integer k>1 and a record M that corresponds to a modular curve. Let Gamma be the congruence subgroup corresponding to the modular curve. For a modular form f on Gamma of weight k>1, let Z_f be the total number of zeros of f, counted with multiplicities, at the cusps of the modular curve. Output: a rational number B such that Z_f>B if and only if f=0",0,2,0,0,0,0,0,0,0,270,,0,0,148,,267,-38,-38,-38,-38,-38
S,FindModularFormsWithVanishingConditions,"Input: M : a record of type ""ModularCurveRec"" with a Q-basis M`F of M_(k,G) already computed. mult : is a sequence of nonnegative integers of the same length as cusps:=M`cusps Let V be the Q-subspace of M_(k,G) consisting of modular forms so that the vanishing of f at the i-th cusp cusps[i]*infty is at least mult[i] for all i. (the parameters ""lll"" and ""saturation"" give some control on how LLL and Saturation is done; these should pprobably be left alone!) Output: Returns the record M with the entry M`F0 being a basis of the Q-vector space V with the same conventions as the basis M`F of M_(k,G). Let d be the dimension of V over K_G (we will have d=#M`F0 div M`KG_degree). The first d modular forms in the sequence M`F0 will be a basis of V over K_G (moreover, they are linearly independent over Cthe complex numbers). The precision of all modular forms will be increased on the fly if required to enforce vanishing conditions",0,2,0,0,0,0,0,0,0,82,,0,0,270,,270,-38,-38,-38,-38,-38
S,FindCuspForms,"Applies ""FindModularFormsWithVanishingConditions"" with mult:=[1,1,...,1]",0,1,0,0,0,0,0,0,0,270,,270,-38,-38,-38,-38,-38
S,EvaluateAtMonomialsOfDegree,"Input F : a sequence of n>0 elements in some ring d : a positive integer. Output: An array A such that for nonnegative integers e_1,..,e_n that sum to d, A[[e_1,..,e_d]] is the product of F[i]^(e_i). This function could be greatly improved but it is better than the most naive implementation",0,2,0,0,0,0,0,0,0,-1,,0,0,-1,,457,-38,-38,-38,-38,-38
S,FindRelationsOverKG,"Input: M: a record describing the modular curve X_G F: a finite sequence of modular forms in some M_(k,G) (each modular form is given as a sequence of q-expansions corresponding to the cusps of the modular curve). We further assume all the q-expansions have coefficients in Q(zeta_N), where N=M`N. d: a positive integer With F=[f_1,..,f_n], let V be the K_G-vector space consisting of homomogeneous polynomials P in K_G[x_1,..,x_n] of degree d with P(f_1,..,f_n)=0. Output: - A basis ""psi"" of a K_G-vector space of homogenous degree d polynomials in K_G[x_1,..,x_n] that contains a basis of V (and might be larger). If modular forms in F are computed to a high enough precision, psi will actually be a basis of V. - A boolean b that is true when the parameter ""Proof"" is set to true and an application of the Sturm bound verifies that psi is a basis of V. When ""Proof"" is set to true, the parameter ""k"" needs to be the weight of the modular forms. An integer t so that for each h in psi, the sum of the orders of the zeros of h(f_1,..,f_n) at the cusps is at least t. (This integer and Sturm's bound can sometimes be used to prove vanishing and verify that psi is a basis of V) When ""OverQ"" is true, a basis of V as a Q-vector space is returned instead. When ""lll"" is true, we use the LLL algorithm to try to make the polynomials nicer. When ""dim_only"" is true, the function instead returns only the cardinality of psi (this can be be faster than actually computing psi)",0,3,0,0,0,0,0,0,0,148,,0,0,82,,0,0,270,,82,-38,-38,-38,-38,-38
S,FindCanonicalModel,"Input: M: a record of type ModularCurveRec (for example produced as output of CreateModularCurveRec) that corresponds to a modular curve X_G with genus g at least 3. Output: An updated record M. The first g elements of M`F0 will be a basis f_1,..,f_g of the K_G-subspace of M_(k,G) consisting of cusps forms. These cusp forms define the canonical map X_G -> P^(g-1)_(K_G); the image is a curve C which is defined by the equations in the sequence M`psi. Moreover, M`psi consists of homomogeneous polynomials that generated the ideal of C. The set psi will actually generate the ideal of K_G[x_1,..,x_g] arising from C. The homogeneous polynomials in psi will all have degree 2 or 3 except in the case where X_G has genus 3 and is not geometrically hyperelliptic (in this case psi consists of a single quartic). If ""lll"" is true, we use the LLL algorithm to hopefully make the model nicer. The quantities ""prec0"" and ""prec_delta"" are technical parameters for the starting precision and increasing precision",0,1,0,0,0,0,0,0,0,270,,36,270,-38,-38,-38,-38
S,FindModelOfXG,"Input: M: a record of type ""ModularCurveRec"" (for example produced as output of CreateModularCurveRec) that corresponds to a modular curve X_G. Function assumes that G contains -I. Output: An updated record M is returned with an explicit model computed. The polynomials cutting out the model can be found in M`psi. Details: The model is found by computing a K_G-subspace V of M_(k,G) given by extra vanishing conditions at the cusps. The k is a positive even integer stored as M`k and the multiplicity at the cusps is given by M`mult (with the same ordering of cusps as given by M). A Q-basis of V is given by M`F0. Let n be the dimension of V as a K_G-vector space; it agrees with #M`F0/M`KG_degree. The first n terms f_1,..,f_n of M`F0 is a K_G-basis of V. The set of polynomials M`psi generats the ideal of K_G[x_1,...,x_n] consisting of polynomials P for which P(f_1,...,f_n)=0. The ideal cuts out the model in P^(n-1)_(K_G). The set M`psi will always consist of homogeneous polynomials of degree 2 and 3. We use the canonical model whenever possible. If desired, the parameter G0 can be set to be an open subgroup of GL(2,Zhat) for which G=M`G is a normal subgroup. We then choose our model so that G0 acts on V. This makes it easy later to compute the automorphisms of our curve coming from G0/G. The quantities ""prec0"" and ""prec_delta"" are technical parameters for the starting precision and increasing precision",0,1,0,0,0,0,0,0,0,270,,270,-38,-38,-38,-38,-38
S,ConvertModularFormExpansions,"Input: M1, M2 : modular curves corresponding to X_G1 and X_G2, respectively, where Gi is an open subgroup of GL(2,Zhat). g : a matrix in GL(2,Zhat) (given as a matrix in GL(2,Z/N) where N is divisible by the level of G1) F : a sequence of (weakly) modular form on M1=X_G1; each modular forms is given as a sequence consisting of its q-expansion at the cusps of M1 (using M1`cusps). wt : the weight of each modular form in F; though we only use the value of wt modulo 2. We assume that for each modular form f in F, f*g is a modular form on M2=X_G2. Output: the sequence of modular forms f*g of M2=X_G2 with f in F. Note: If the wrong weight ""wt"" is given, the resulting output might be off by a sign",0,4,0,0,0,0,0,0,0,-1,,0,0,-1,,0,0,-1,,0,0,-1,,82,-38,-38,-38,-38,-38
S,FindModularForms,"Input k: an integer > 1, M: a modular curve given by a record of type ""ModularCurveRec"" (for example produced as output of CreateModularCurveRec) associated to an open subgroup G of GL(2,Zhat). Let N be the level of G. Output: The record M with M`F updated to consist of a basis of the space of modular forms M_(k,G) := M_k(Gamma(N),Q(zeta_N))^G as a vector space over Q. Let d be the dimension of M_(k,G) over K_G (note: d=#M`F div M`KG_degree). The first d modular forms in the sequence M`F will be a basis of M_(k,G) over K_G (moreover, they are linearly independent over C). A modular form is given as a sequence consisting of its q-expansion at each cusp (with the ordering of cusps coming from M`cusps). Enough terms of the q-expansions of each modular form is computed so that it is uniquely determined in M_(k,G). [M is returned with the following entries computed/updated: k, dimMk, dimSk, prec_sturm, prec, F] The technical parameters ""lll"" and ""saturation"" can adjust when the function takes saturations and applies LLL to matrices. The technical parameter ""prime_tolerance"" is for adjusting how often we consider new primes when computing rank of matrices via reduction",0,2,0,0,0,0,0,0,0,270,,0,0,148,,270,-38,-38,-38,-38,-38
S,IncreaseModularFormPrecision,"Input M: a modular curve given as a record of type ""ModularCurveRec"" for which M`F is defined and consist of modular forms (as outputted by ""FindModularForms""). prec: a sequence of positive integers; one integer for each cusp. Output: Returns M with the q-expansions of the modular forms in M`F extended so that they are computed at least up to O(q^(prec[i]/w_i) at the i-th cusp of M, where w_i is the width of the i-th cusp. This also extends the modular forms in M`F0 if present",0,2,0,0,0,0,0,0,0,82,,0,0,270,,270,-38,-38,-38,-38,-38
S,IncreaseModularFormPrecision,"Same as other version but q-expansions at all cusps are computed up to O(q^(prec/m)), where m=M`sl2level and prec is a nonnegative integer",0,2,0,0,0,0,0,0,0,148,,0,0,270,,270,-38,-38,-38,-38,-38
S,AutomorphismOfModularForms,"Input: a modular curve M=X_G, a sequence F of modular forms in M_(k,G) for some k>1 that are linearly independent over K_G, and a matrix g in GL(2,Zhat) that lies in the normalizer of G and acts on the K_G-vector V space spanned by F. (The parameter ""k"" is an integer congruent to k modulo 2.) Output: the matrix C that describes the action of g on V in terms of the basis F; it will be a square matrix with entries in K_G. When ""OverQ"" is set to true, then it performs as described above except with K_G replaced by Q",0,3,0,0,0,0,0,0,0,180,,0,0,82,,0,0,270,,82,-38,-38,-38,-38,-38
